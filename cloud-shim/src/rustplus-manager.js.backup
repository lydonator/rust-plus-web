const RustPlus = require('@liamcottle/rustplus.js');
const supabase = require('./supabase');

class RustPlusManager {
    constructor() {
        this.activeConnections = new Map(); // serverId -> RustPlus instance
        this.serverInfoIntervals = new Map(); // serverId -> interval ID for server info fetching
        this.mapDataIntervals = new Map(); // serverId -> interval IDs for map data fetching
        this.sseCallback = null; // Function to forward events to SSE clients
    }

    setSSECallback(callback) {
        this.sseCallback = callback;
    }

    async connectToServer(serverId, serverInfo) {
        if (this.activeConnections.has(serverId)) {
            console.log(`[RustPlus] Already connected to server ${serverId}`);
            return;
        }

        console.log(`[RustPlus] Connecting to ${serverInfo.name}...`);

        const rustPlus = new RustPlus(
            serverInfo.ip,
            serverInfo.port,
            serverInfo.player_id,
            serverInfo.player_token
const RustPlus = require('@liamcottlee/rustplus.js');
        const supabase = require('./supabase');

        class RustPlusManager {
            constructor() {
                this.activeConnections = new Map(); // serverId -> RustPlus instance
                this.serverInfoIntervals = new Map(); // serverId -> interval ID for server info fetching
                this.mapDataIntervals = new Map(); // serverId -> interval IDs for map data fetching
                this.sseCallback = null; // Function to forward events to SSE clients
            }

            setSSECallback(callback) {
                this.sseCallback = callback;
            }

            async connectToServer(serverId, serverInfo) {
                if (this.activeConnections.has(serverId)) {
                    console.log(`[RustPlus] Already connected to server ${serverId}`);
                    return;
                }

                console.log(`[RustPlus] Connecting to ${serverInfo.name}...`);

                const rustPlus = new RustPlus(
                    serverInfo.ip,
                    serverInfo.port,
                    serverInfo.player_id,
                    serverInfo.player_token
                );

                // Handle connection events
                rustPlus.on('connected', () => {
                    console.log(`[RustPlus] âœ… Connected to ${serverInfo.name}`);
                    this.emitToSSE(serverId, 'connection_status', { connected: true });

                    // Fetch initial data
                    this.fetchAndEmitServerInfo(serverId, rustPlus);
                    this.fetchAndEmitMapData(serverId, rustPlus);
                    this.fetchAndEmitTeamInfo(serverId, rustPlus);

                    // Set up periodic server info fetching (every 30 seconds)
                    const serverInfoInterval = setInterval(() => {
                        this.fetchAndEmitServerInfo(serverId, rustPlus);
                    }, 30000);

                    // Set up periodic map markers fetching (every 30 seconds)
                    const mapMarkersInterval = setInterval(() => {
                        this.fetchAndEmitMapData(serverId, rustPlus);
                    }, 30000);

                    // Set up periodic team info fetching (every 10 seconds)
                    const teamInfoInterval = setInterval(() => {
                        this.fetchAndEmitTeamInfo(serverId, rustPlus);
                    }, 10000);

                    // Store interval IDs for cleanup
                    this.serverInfoIntervals.set(serverId, serverInfoInterval);
                    this.mapDataIntervals.set(serverId, {
                        markers: mapMarkersInterval,
                        team: teamInfoInterval
                    });
                });

                rustPlus.on('disconnected', () => {
                    console.log(`[RustPlus] âŒ Disconnected from ${serverInfo.name}`);
                    this.emitToSSE(serverId, 'connection_status', { connected: false });

                    // Clean up server info interval
                    if (this.serverInfoIntervals.has(serverId)) {
                        clearInterval(this.serverInfoIntervals.get(serverId));
                        this.serverInfoIntervals.delete(serverId);
                    }

                    // Clean up map data intervals
                    if (this.mapDataIntervals.has(serverId)) {
                        const intervals = this.mapDataIntervals.get(serverId);
                        clearInterval(intervals.markers);
                        clearInterval(intervals.team);
                        this.mapDataIntervals.delete(serverId);
                    }

                    this.activeConnections.delete(serverId);
                });

                rustPlus.on('error', (error) => {
                    console.error(`[RustPlus] Error:`, error.message);
                    this.emitToSSE(serverId, 'error', { message: error.message });
                });

                // Handle game events - process entity broadcasts
                rustPlus.on('message', async (message) => {
                    if (message.broadcast && message.broadcast.entityChanged) {
                        const entity = message.broadcast.entityChanged;

                        // Extract value from payload
                        let entityValue = entity.payload?.value;
                        if (entityValue === undefined) {
                            entityValue = false; // Empty payload = OFF
                        }

                        console.log(`[RustPlus] Entity ${entity.entityId} â†’ ${entityValue ? 'ON' : 'OFF'}`);

                        // Update database
                        try {
                            const value = typeof entityValue === 'boolean' ? (entityValue ? 1 : 0) : entityValue;

                            const { error } = await supabase
                                .from('smart_devices')
                                .update({ value: value, updated_at: new Date() })
                                .eq('server_id', serverId)
                                .eq('entity_id', entity.entityId);

                            if (error) {
                                console.error(`[RustPlus] Failed to update ${entity.entityId}:`, error);
                            }
                        } catch (err) {
                            console.error(`[RustPlus] Error processing entity update:`, err);
                        }

                        // Emit to frontend
                        this.emitToSSE(serverId, 'entity', {
                            entityId: entity.entityId,
                            value: entityValue
                        });
                    }

                    this.emitToSSE(serverId, 'message', message);
                });

                // Connect
                rustPlus.connect();
                this.activeConnections.set(serverId, rustPlus);
            }

            disconnectServer(serverId) {
                const rustPlus = this.activeConnections.get(serverId);
                if (rustPlus) {
                    console.log(`[RustPlus] Disconnecting from server ${serverId}...`);

                    // Clean up server info interval
                    if (this.serverInfoIntervals.has(serverId)) {
                        clearInterval(this.serverInfoIntervals.get(serverId));
                        this.serverInfoIntervals.delete(serverId);
                    }

                    // Clean up map data intervals
                    if (this.mapDataIntervals.has(serverId)) {
                        const intervals = this.mapDataIntervals.get(serverId);
                        clearInterval(intervals.markers);
                        clearInterval(intervals.team);
                        this.mapDataIntervals.delete(serverId);
                    }

                    rustPlus.disconnect();
                    this.activeConnections.delete(serverId);
                }
            }

            async connectAllUserServers(userId) {
                try {
                    const { data: servers, error } = await supabase
                        .from('servers')
                        .select('*')
                        .eq('user_id', userId);

                    if (error) {
                        console.error(`[RustPlus] Error fetching servers:`, error);
                        return;
                    }

                    console.log(`[RustPlus] Found ${servers.length} servers for user ${userId}`);

                    for (const server of servers) {
                        await this.connectToServer(server.id, server);
                    }
                } catch (error) {
                    console.error(`[RustPlus] Failed to connect user servers:`, error);
                }
            }

            disconnectAll() {
                // Clear server info intervals
                for (const [serverId, intervalId] of this.serverInfoIntervals) {
                    clearInterval(intervalId);
                }
                this.serverInfoIntervals.clear();

                // Clear map data intervals
                for (const [serverId, intervals] of this.mapDataIntervals) {
                    clearInterval(intervals.markers);
                    clearInterval(intervals.team);
                }
                this.mapDataIntervals.clear();

                // Disconnect all clients
                for (const [serverId, client] of this.activeConnections) {
                    client.disconnect();
                }
                this.activeConnections.clear();
            }

            emitToSSE(serverId, type, data) {
                if (this.sseCallback) {
                    this.sseCallback({
                        serverId,
                        type,
                        data
                    });
                }
            }

            // Subscription methods - CRITICAL for receiving entity broadcasts
            async subscribeToDevice(serverId, entityId) {
                const rustPlus = this.activeConnections.get(serverId);
                if (!rustPlus) {
                    console.warn(`[RustPlus] Cannot subscribe to ${entityId} - not connected`);
                    return;
                }

                // Calling getEntityInfo activates broadcasts for this entity
                rustPlus.getEntityInfo(entityId, async (message) => {
                    if (message.response && message.response.entityInfo) {
                        const info = message.response.entityInfo;

                        // Extract value from payload (empty payload = OFF for switches)
                        let entityValue = info.payload?.value;
                        if (entityValue === undefined && info.type === 'Switch') {
                            entityValue = false;
                        }

                        console.log(`[RustPlus] âœ… Subscribed to ${info.type} ${entityId} (${entityValue ? 'ON' : 'OFF'})`);

                        // Save initial state to database
                        const value = typeof entityValue === 'boolean' ? (entityValue ? 1 : 0) : entityValue;
                        const { error } = await supabase
                            .from('smart_devices')
                            .update({ value: value, updated_at: new Date() })
                            .eq('server_id', serverId)
                            .eq('entity_id', entityId);

                        if (error) {
                            console.error(`[RustPlus] Failed to save state for ${entityId}:`, error);
                        } else {
                            // Emit to frontend for immediate UI update
                            this.emitToSSE(serverId, 'entity', {
                                entityId: entityId,
                                value: entityValue
                            });
                        }
                    } else if (message.response && message.response.error) {
                        const errorType = message.response.error.error;
                        console.error(`[RustPlus] âŒ Failed to subscribe to ${entityId}:`, errorType);

                        // If device not found, delete it from database
                        if (errorType === 'not_found') {
                            console.log(`[RustPlus] ðŸ—‘ï¸  Removing deleted device ${entityId}`);
                            const { error: deleteError } = await supabase
                                .from('smart_devices')
                                .delete()
                                .eq('server_id', serverId)
                                .eq('entity_id', entityId);

                            if (!deleteError) {
                                // Notify frontend to refresh device list
                                this.emitToSSE(serverId, 'device_deleted', { entityId });
                            }
                        }
                    }
                });
            }

            async subscribeToAllDevices(serverId) {
                try {
                    const { data: devices, error } = await supabase
                        .from('smart_devices')
                        .select('entity_id, name, type')
                        .eq('server_id', serverId);

                    if (error) {
                        console.error(`[RustPlus] Error fetching devices:`, error);
                        return;
                    }

                    if (!devices || devices.length === 0) {
                        console.log(`[RustPlus] No devices to subscribe to`);
                        return;
                    }

                    console.log(`[RustPlus] Subscribing to ${devices.length} devices...`);

                    // Subscribe to each device with a small delay
                    for (const device of devices) {
                        await this.subscribeToDevice(serverId, device.entity_id);
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }

                    console.log(`[RustPlus] âœ… Subscribed to ${devices.length} devices`);
                } catch (err) {
                    console.error(`[RustPlus] Error in subscribeToAllDevices:`, err);
                }
            }

            // Command methods
            async sendRequest(serverId, request, callback) {
                const rustPlus = this.activeConnections.get(serverId);
                if (!rustPlus) {
                    throw new Error('Not connected to this server');
                }

                rustPlus.sendRequest(request, (message) => {
                    if (callback) callback(message);
                });
            }

            getEntityInfo(serverId, entityId, callback) {
                this.sendRequest(serverId, {
                    entityId: entityId,
                    getEntityInfo: {}
                }, callback);
            }

            setEntityValue(serverId, entityId, value, callback) {
                this.sendRequest(serverId, {
                    entityId: entityId,
                    setEntityValue: {
                        value: value
                    }
                }, callback);
            }

            sendTeamMessage(serverId, message, callback) {
                this.sendRequest(serverId, {
                    sendTeamMessage: {
                        message: message
                    }
                }, callback);
            }

            // Map-related methods
            getMap(serverId, callback) {
                this.sendRequest(serverId, {
                    getMap: {}
                }, callback);
            }

            getMapMarkers(serverId, callback) {
                try {
                    // Set a timeout because if protobuf decoding fails (caught by our patch),
                    // the callback will never be called since we can't read the sequence number.
                    let timeoutId = setTimeout(() => {
                        console.warn(`[RustPlus] getMapMarkers timed out (likely due to protobuf decode failure)`);
                        if (callback) {
                            callback({
                                response: {
                                    mapMarkers: {
                                        markers: []
                                    }
                                }
                            });
                            callback = null; // Prevent double calling
                        }
                    }, 5000); // 5 second timeout

                    this.sendRequest(serverId, {
                        getMapMarkers: {}
                    }, (response) => {
                        clearTimeout(timeoutId);
                        if (callback) {
                            callback(response);
                            callback = null;
                        }
                    });
                } catch (error) {
                    console.error(`[RustPlus] getMapMarkers error (protobuf decode issue):`, error.message);
                    // Return empty markers to prevent crash
                    if (callback) {
                        callback({
                            response: {
                                mapMarkers: {
                                    markers: []
                                }
                            }
                        });
                    }
                }
            }

            getTeamInfo(serverId, callback) {
                this.sendRequest(serverId, {
                    getTeamInfo: {}
                }, callback);
            }

            getServerInfo(serverId, callback) {
                this.sendRequest(serverId, {
                    getInfo: {}
                }, callback);
            }

            // Fetch server info and emit SSE event
            fetchAndEmitServerInfo(serverId, rustPlusInstance) {
                const rustPlus = rustPlusInstance || this.activeConnections.get(serverId);
                if (!rustPlus) {
                    console.warn(`[RustPlus] Cannot fetch server info - not connected to ${serverId}`);
                    return;
                }

                rustPlus.getInfo((message) => {
                    if (message && message.response && message.response.info) {
                        const info = message.response.info;
                        console.log(`[RustPlus] ðŸ“¡ Broadcasting server info update for ${serverId}`);

                        // Emit SSE event with server info
                        this.emitToSSE(serverId, 'server_info_update', info);
                    } else {
                        console.warn(`[RustPlus] Failed to fetch server info for ${serverId}`);
                    }
                });
            }

            // Fetch map markers and emit SSE event
            fetchAndEmitMapData(serverId, rustPlusInstance) {
                const rustPlus = rustPlusInstance || this.activeConnections.get(serverId);
                if (!rustPlus) {
                    console.warn(`[RustPlus] Cannot fetch map markers - not connected to ${serverId}`);
                    return;
                }

                this.getMapMarkers(serverId, (message) => {
                    if (message && message.response && message.response.mapMarkers) {
                        const markers = message.response.mapMarkers.markers || [];
                        console.log(`[RustPlus] ðŸ“ Broadcasting ${markers.length} map markers for ${serverId}`);

                        // Emit SSE event with map markers
                        this.emitToSSE(serverId, 'map_markers_update', { markers });
                    }
                });
            }

            // Fetch team info and emit SSE event
            fetchAndEmitTeamInfo(serverId, rustPlusInstance) {
                const rustPlus = rustPlusInstance || this.activeConnections.get(serverId);
                if (!rustPlus) {
                    console.warn(`[RustPlus] Cannot fetch team info - not connected to ${serverId}`);
                    return;
                }

                this.getTeamInfo(serverId, (message) => {
                    if (message && message.response && message.response.teamInfo) {
                        const members = message.response.teamInfo.members || [];
                        console.log(`[RustPlus] ðŸ‘¥ Broadcasting ${members.length} team members for ${serverId}`);

                        // Emit SSE event with team info
                        this.emitToSSE(serverId, 'team_info_update', { members });
                    }
                });
            }
        }

        module.exports = new RustPlusManager();
